// @generated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `SomeService`.
pub mod some_service {

    pub type BounceMapError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::some_service::BounceMapExn> for BounceMapError {
        fn from(e: crate::services::some_service::BounceMapExn) -> Self {
            match e {
                crate::services::some_service::BounceMapExn::ApplicationException(aexn) =>
                    BounceMapError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum BounceMapReader {}

    impl ::fbthrift::help::DeserializeExn for BounceMapReader {
        type Success = included__types::SomeMap;
        type Error = BounceMapError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Map, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BounceMapError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "BounceMapError"),
                )
                .into(),
            )
        }
    }

    pub type BinaryKeyedMapError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::some_service::BinaryKeyedMapExn> for BinaryKeyedMapError {
        fn from(e: crate::services::some_service::BinaryKeyedMapExn) -> Self {
            match e {
                crate::services::some_service::BinaryKeyedMapExn::ApplicationException(aexn) =>
                    BinaryKeyedMapError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum BinaryKeyedMapReader {}

    impl ::fbthrift::help::DeserializeExn for BinaryKeyedMapReader {
        type Success = ::std::collections::BTreeMap<crate::types::TBinary, ::std::primitive::i64>;
        type Error = BinaryKeyedMapError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Map, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BinaryKeyedMapError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "BinaryKeyedMapError"),
                )
                .into(),
            )
        }
    }

}

