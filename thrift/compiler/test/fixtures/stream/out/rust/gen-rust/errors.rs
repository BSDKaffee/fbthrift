// @generated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `PubSubStreamingService`.
pub mod pub_sub_streaming_service {

    pub trait AsFooEx {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx>;
    }

    impl AsFooEx for ::anyhow::Error {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            for cause in self.chain() {
                if let Some(ServicethrowsError::e(e)) = cause.downcast_ref::<ServicethrowsError>() {
                    return Some(e);
                }
                if let Some(Servicethrows2Error::e1(e)) = cause.downcast_ref::<Servicethrows2Error>() {
                    return Some(e);
                }
                if let Some(BoththrowsError::e(e)) = cause.downcast_ref::<BoththrowsError>() {
                    return Some(e);
                }
                if let Some(ResponseandstreamservicethrowsError::e(e)) = cause.downcast_ref::<ResponseandstreamservicethrowsError>() {
                    return Some(e);
                }
                if let Some(ResponseandstreamboththrowsError::e(e)) = cause.downcast_ref::<ResponseandstreamboththrowsError>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub trait AsFooEx2 {
        fn as_foo_ex2(&self) -> Option<&crate::types::FooEx2>;
    }

    impl AsFooEx2 for ::anyhow::Error {
        fn as_foo_ex2(&self) -> Option<&crate::types::FooEx2> {
            for cause in self.chain() {
                if let Some(Servicethrows2Error::e2(e)) = cause.downcast_ref::<Servicethrows2Error>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub type ReturnstreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::ReturnstreamExn {
        type Success =     ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamStreamExn>>
;
        type Return = ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>;
        type Error = ReturnstreamError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let stream = success;
                    ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from)))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamExn> for ReturnstreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamExn::ApplicationException(aexn) =>
                    ReturnstreamError::ApplicationException(aexn),
            }
        }
    }

    pub type ReturnstreamStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamStreamExn> for ReturnstreamStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamStreamExn::ApplicationException(aexn) =>
                    ReturnstreamStreamError::ApplicationException(aexn),
            }
        }
    }

    pub type StreamthrowsError = ::fbthrift::NonthrowingFunctionError;

    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::StreamthrowsExn {
        type Success =     ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::StreamthrowsStreamExn>>
;
        type Return = ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>;
        type Error = StreamthrowsError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let stream = success;
                    ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from)))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::StreamthrowsExn> for StreamthrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::StreamthrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::StreamthrowsExn::ApplicationException(aexn) =>
                    StreamthrowsError::ApplicationException(aexn),
            }
        }
    }

    #[derive(Debug)]
    pub enum StreamthrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for StreamthrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::streamthrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::streamthrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::streamthrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::streamthrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for StreamthrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for StreamthrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for StreamthrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for StreamthrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::StreamthrowsStreamExn> for StreamthrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::StreamthrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::ApplicationException(aexn) =>
                    StreamthrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::e(exn) =>
                    StreamthrowsStreamError::e(exn),
            }
        }
    }

    /// Errors for servicethrows (client side).
    #[derive(Debug)]
    pub enum ServicethrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ServicethrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ServicethrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ServicethrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ServicethrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ServicethrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ServicethrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::ServicethrowsExn {
        type Success =     ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ServicethrowsStreamExn>>
;
        type Return = ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>;
        type Error = ServicethrowsError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let stream = success;
                    ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from)))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ServicethrowsExn> for ServicethrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ServicethrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(aexn) =>
                    ServicethrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ServicethrowsExn::e(exn) =>
                    ServicethrowsError::e(exn),
            }
        }
    }

    pub type ServicethrowsStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ServicethrowsStreamExn> for ServicethrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ServicethrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ServicethrowsStreamExn::ApplicationException(aexn) =>
                    ServicethrowsStreamError::ApplicationException(aexn),
            }
        }
    }

    /// Errors for servicethrows2 (client side).
    #[derive(Debug)]
    pub enum Servicethrows2Error {
        e1(crate::types::FooEx),
        e2(crate::types::FooEx2),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for Servicethrows2Error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e1(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with variant `e1`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with e1(FooEx)")?;
                    }
                }
                Self::e2(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with variant `e2`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with e2(FooEx2)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows2 failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows2 failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for Servicethrows2Error {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e1(ref inner) => {
                    Some(inner)
                }
                Self::e2(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for Servicethrows2Error {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e1(e)
        }
    }

    impl AsFooEx for Servicethrows2Error {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e1(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx2> for Servicethrows2Error {
        fn from(e: crate::types::FooEx2) -> Self {
            Self::e2(e)
        }
    }

    impl AsFooEx2 for Servicethrows2Error {
        fn as_foo_ex2(&self) -> Option<&crate::types::FooEx2> {
            match self {
                Self::e2(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for Servicethrows2Error {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for Servicethrows2Error {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::Servicethrows2Exn {
        type Success =     ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::Servicethrows2StreamExn>>
;
        type Return = ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>;
        type Error = Servicethrows2Error;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let stream = success;
                    ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from)))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::Servicethrows2Exn> for Servicethrows2Error {
        fn from(e: crate::services::pub_sub_streaming_service::Servicethrows2Exn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(aexn) =>
                    Servicethrows2Error::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::e1(exn) =>
                    Servicethrows2Error::e1(exn),
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::e2(exn) =>
                    Servicethrows2Error::e2(exn),
            }
        }
    }

    pub type Servicethrows2StreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::Servicethrows2StreamExn> for Servicethrows2StreamError {
        fn from(e: crate::services::pub_sub_streaming_service::Servicethrows2StreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::Servicethrows2StreamExn::ApplicationException(aexn) =>
                    Servicethrows2StreamError::ApplicationException(aexn),
            }
        }
    }

    /// Errors for boththrows (client side).
    #[derive(Debug)]
    pub enum BoththrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BoththrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::boththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::boththrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BoththrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for BoththrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for BoththrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BoththrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BoththrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::BoththrowsExn {
        type Success =     ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::BoththrowsStreamExn>>
;
        type Return = ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>;
        type Error = BoththrowsError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let stream = success;
                    ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from)))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsExn> for BoththrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(aexn) =>
                    BoththrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::BoththrowsExn::e(exn) =>
                    BoththrowsError::e(exn),
            }
        }
    }

    #[derive(Debug)]
    pub enum BoththrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BoththrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::boththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::boththrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BoththrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for BoththrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BoththrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BoththrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsStreamExn> for BoththrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::ApplicationException(aexn) =>
                    BoththrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::e(exn) =>
                    BoththrowsStreamError::e(exn),
            }
        }
    }

    pub type ResponseandstreamstreamthrowsError = ::fbthrift::NonthrowingFunctionError;

    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn {
        type Success = (
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn>>
)
;
        type Return = (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>);
        type Error = ResponseandstreamstreamthrowsError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let (resp, stream) = success;
                    (resp, ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from))))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn> for ResponseandstreamstreamthrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn::ApplicationException(aexn) =>
                    ResponseandstreamstreamthrowsError::ApplicationException(aexn),
            }
        }
    }

    #[derive(Debug)]
    pub enum ResponseandstreamstreamthrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamstreamthrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamstreamthrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for ResponseandstreamstreamthrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamstreamthrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamstreamthrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn> for ResponseandstreamstreamthrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::ApplicationException(aexn) =>
                    ResponseandstreamstreamthrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::e(exn) =>
                    ResponseandstreamstreamthrowsStreamError::e(exn),
            }
        }
    }

    /// Errors for responseandstreamservicethrows (client side).
    #[derive(Debug)]
    pub enum ResponseandstreamservicethrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamservicethrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamservicethrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ResponseandstreamservicethrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ResponseandstreamservicethrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamservicethrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamservicethrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn {
        type Success = (
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn>>
)
;
        type Return = (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>);
        type Error = ResponseandstreamservicethrowsError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let (resp, stream) = success;
                    (resp, ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from))))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn> for ResponseandstreamservicethrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(aexn) =>
                    ResponseandstreamservicethrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::e(exn) =>
                    ResponseandstreamservicethrowsError::e(exn),
            }
        }
    }

    pub type ResponseandstreamservicethrowsStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn> for ResponseandstreamservicethrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn::ApplicationException(aexn) =>
                    ResponseandstreamservicethrowsStreamError::ApplicationException(aexn),
            }
        }
    }

    /// Errors for responseandstreamboththrows (client side).
    #[derive(Debug)]
    pub enum ResponseandstreamboththrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamboththrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamboththrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ResponseandstreamboththrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ResponseandstreamboththrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamboththrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamboththrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn {
        type Success = (
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn>>
)
;
        type Return = (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>);
        type Error = ResponseandstreamboththrowsError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let (resp, stream) = success;
                    (resp, ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from))))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn> for ResponseandstreamboththrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(aexn) =>
                    ResponseandstreamboththrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::e(exn) =>
                    ResponseandstreamboththrowsError::e(exn),
            }
        }
    }

    #[derive(Debug)]
    pub enum ResponseandstreamboththrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamboththrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamboththrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for ResponseandstreamboththrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamboththrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamboththrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn> for ResponseandstreamboththrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::ApplicationException(aexn) =>
                    ResponseandstreamboththrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::e(exn) =>
                    ResponseandstreamboththrowsStreamError::e(exn),
            }
        }
    }

    pub type ReturnstreamFastError = ::fbthrift::NonthrowingFunctionError;

    impl ::fbthrift::help::StreamExn for crate::services::pub_sub_streaming_service::ReturnstreamFastExn {
        type Success =     ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn>>
;
        type Return = ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>;
        type Error = ReturnstreamFastError;

        fn map_stream(res: ::std::result::Result<Self::Success, Self>) -> ::std::result::Result<Self::Return, Self::Error> {
            match res {
                ::std::result::Result::Ok(success) => ::std::result::Result::Ok({
                    let stream = success;
                    ::futures::StreamExt::boxed(::futures::StreamExt::map(stream, |res| res.map_err(::std::convert::From::from)))
                }),
                ::std::result::Result::Err(exn) => ::std::result::Result::Err(::std::convert::From::from(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamFastExn> for ReturnstreamFastError {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamFastExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamFastExn::ApplicationException(aexn) =>
                    ReturnstreamFastError::ApplicationException(aexn),
            }
        }
    }

    pub type ReturnstreamFastStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn> for ReturnstreamFastStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn::ApplicationException(aexn) =>
                    ReturnstreamFastStreamError::ApplicationException(aexn),
            }
        }
    }

}

