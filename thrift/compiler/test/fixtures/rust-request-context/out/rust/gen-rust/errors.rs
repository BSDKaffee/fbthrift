// @generated by Thrift for thrift/compiler/test/fixtures/rust-request-context/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `MyInteraction`.
pub mod my_interaction {

    pub type PingError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_interaction::PingExn> for PingError {
        fn from(e: crate::services::my_interaction::PingExn) -> Self {
            match e {
                crate::services::my_interaction::PingExn::ApplicationException(aexn) =>
                    PingError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum PingReader {}

    impl ::fbthrift::help::DeserializeExn for PingReader {
        type Success = ();
        type Error = PingError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "PingError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

}

/// Error definitions for `MyService`.
pub mod my_service {

    pub type PingError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::PingExn> for PingError {
        fn from(e: crate::services::my_service::PingExn) -> Self {
            match e {
                crate::services::my_service::PingExn::ApplicationException(aexn) =>
                    PingError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum PingReader {}

    impl ::fbthrift::help::DeserializeExn for PingReader {
        type Success = ();
        type Error = PingError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "PingError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type GetRandomDataError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::GetRandomDataExn> for GetRandomDataError {
        fn from(e: crate::services::my_service::GetRandomDataExn) -> Self {
            match e {
                crate::services::my_service::GetRandomDataExn::ApplicationException(aexn) =>
                    GetRandomDataError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum GetRandomDataReader {}

    impl ::fbthrift::help::DeserializeExn for GetRandomDataReader {
        type Success = ::std::string::String;
        type Error = GetRandomDataError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::String, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "GetRandomDataError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "GetRandomDataError"),
                )
                .into(),
            )
        }
    }

    pub type HasDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::HasDataByIdExn> for HasDataByIdError {
        fn from(e: crate::services::my_service::HasDataByIdExn) -> Self {
            match e {
                crate::services::my_service::HasDataByIdExn::ApplicationException(aexn) =>
                    HasDataByIdError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum HasDataByIdReader {}

    impl ::fbthrift::help::DeserializeExn for HasDataByIdReader {
        type Success = ::std::primitive::bool;
        type Error = HasDataByIdError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Bool, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Bool, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "HasDataByIdError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "HasDataByIdError"),
                )
                .into(),
            )
        }
    }

    pub type GetDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::GetDataByIdExn> for GetDataByIdError {
        fn from(e: crate::services::my_service::GetDataByIdExn) -> Self {
            match e {
                crate::services::my_service::GetDataByIdExn::ApplicationException(aexn) =>
                    GetDataByIdError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum GetDataByIdReader {}

    impl ::fbthrift::help::DeserializeExn for GetDataByIdReader {
        type Success = ::std::string::String;
        type Error = GetDataByIdError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::String, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "GetDataByIdError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "GetDataByIdError"),
                )
                .into(),
            )
        }
    }

    pub type PutDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::PutDataByIdExn> for PutDataByIdError {
        fn from(e: crate::services::my_service::PutDataByIdExn) -> Self {
            match e {
                crate::services::my_service::PutDataByIdExn::ApplicationException(aexn) =>
                    PutDataByIdError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum PutDataByIdReader {}

    impl ::fbthrift::help::DeserializeExn for PutDataByIdReader {
        type Success = ();
        type Error = PutDataByIdError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "PutDataByIdError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type LobDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::LobDataByIdExn> for LobDataByIdError {
        fn from(e: crate::services::my_service::LobDataByIdExn) -> Self {
            match e {
                crate::services::my_service::LobDataByIdExn::ApplicationException(aexn) =>
                    LobDataByIdError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum LobDataByIdReader {}

    impl ::fbthrift::help::DeserializeExn for LobDataByIdReader {
        type Success = ();
        type Error = LobDataByIdError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "LobDataByIdError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type StreamByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdExn> for StreamByIdError {
        fn from(e: crate::services::my_service::StreamByIdExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdExn::ApplicationException(aexn) =>
                    StreamByIdError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StreamByIdReader {}

    impl ::fbthrift::help::DeserializeExn for StreamByIdReader {
        type Success = ();
        type Error = StreamByIdError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamByIdError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type StreamByIdStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdStreamExn> for StreamByIdStreamError {
        fn from(e: crate::services::my_service::StreamByIdStreamExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdStreamExn::ApplicationException(aexn) =>
                    StreamByIdStreamError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StreamByIdStreamReader {}

    impl ::fbthrift::help::DeserializeExn for StreamByIdStreamReader {
        type Success = crate::types::MyStruct;
        type Error = StreamByIdStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamByIdStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "StreamByIdStreamError"),
                )
                .into(),
            )
        }
    }

    pub type StreamByIdWithExceptionError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithExceptionExn> for StreamByIdWithExceptionError {
        fn from(e: crate::services::my_service::StreamByIdWithExceptionExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithExceptionExn::ApplicationException(aexn) =>
                    StreamByIdWithExceptionError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StreamByIdWithExceptionReader {}

    impl ::fbthrift::help::DeserializeExn for StreamByIdWithExceptionReader {
        type Success = ();
        type Error = StreamByIdWithExceptionError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamByIdWithExceptionError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    #[derive(Debug)]
    pub enum StreamByIdWithExceptionStreamError {
        e(crate::types::MyException),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for StreamByIdWithExceptionStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "MyService::streamByIdWithException failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "MyService::streamByIdWithException failed with e(MyException)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "MyService::streamByIdWithException failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "MyService::streamByIdWithException failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for StreamByIdWithExceptionStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::MyException> for StreamByIdWithExceptionStreamError {
        fn from(e: crate::types::MyException) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for StreamByIdWithExceptionStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for StreamByIdWithExceptionStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithExceptionStreamExn> for StreamByIdWithExceptionStreamError {
        fn from(e: crate::services::my_service::StreamByIdWithExceptionStreamExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithExceptionStreamExn::ApplicationException(aexn) =>
                    StreamByIdWithExceptionStreamError::ApplicationException(aexn),
                crate::services::my_service::StreamByIdWithExceptionStreamExn::e(exn) =>
                    StreamByIdWithExceptionStreamError::e(exn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StreamByIdWithExceptionStreamReader {}

    impl ::fbthrift::help::DeserializeExn for StreamByIdWithExceptionStreamReader {
        type Success = crate::types::MyStruct;
        type Error = StreamByIdWithExceptionStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamByIdWithExceptionStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "StreamByIdWithExceptionStreamError"),
                )
                .into(),
            )
        }
    }

    pub type StreamByIdWithResponseError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithResponseExn> for StreamByIdWithResponseError {
        fn from(e: crate::services::my_service::StreamByIdWithResponseExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithResponseExn::ApplicationException(aexn) =>
                    StreamByIdWithResponseError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StreamByIdWithResponseReader {}

    impl ::fbthrift::help::DeserializeExn for StreamByIdWithResponseReader {
        type Success = crate::types::MyDataItem;
        type Error = StreamByIdWithResponseError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamByIdWithResponseError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "StreamByIdWithResponseError"),
                )
                .into(),
            )
        }
    }

    pub type StreamByIdWithResponseStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithResponseStreamExn> for StreamByIdWithResponseStreamError {
        fn from(e: crate::services::my_service::StreamByIdWithResponseStreamExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithResponseStreamExn::ApplicationException(aexn) =>
                    StreamByIdWithResponseStreamError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StreamByIdWithResponseStreamReader {}

    impl ::fbthrift::help::DeserializeExn for StreamByIdWithResponseStreamReader {
        type Success = crate::types::MyStruct;
        type Error = StreamByIdWithResponseStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamByIdWithResponseStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "StreamByIdWithResponseStreamError"),
                )
                .into(),
            )
        }
    }

    pub type StartPingInteractionError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StartPingInteractionExn> for StartPingInteractionError {
        fn from(e: crate::services::my_service::StartPingInteractionExn) -> Self {
            match e {
                crate::services::my_service::StartPingInteractionExn::ApplicationException(aexn) =>
                    StartPingInteractionError::ApplicationException(aexn),
            }
        }
    }

    #[doc(hidden)]
    pub enum StartPingInteractionReader {}

    impl ::fbthrift::help::DeserializeExn for StartPingInteractionReader {
        type Success = ();
        type Error = StartPingInteractionError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StartPingInteractionError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

}

